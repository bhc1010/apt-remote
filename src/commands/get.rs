//! # `apt-remote get` command
//!
//! Downloads package files and metadata listed in a `uri.toml` file
//! previously generated by the `apt-remote set` command.
//!
//! Supports both package `.deb` downloads (Install/Upgrade mode)
//! and APT source metadata downloads (Update mode), including automatic
//! decompression of `.xz` files.

use crate::uri::{UriFile, RemoteMode};

use anyhow::{Context, Result};
use clap::Args;
use colored::Colorize;
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};
use rayon::prelude::*;
use reqwest::blocking::Client;
use xz2::read::XzDecoder;

use std::fs::{self, File};
use std::path::Path;
use std::io::{BufReader, BufWriter, Write};
use std::sync::Arc;
use std::time::Duration;

/// CLI arguments for the `apt-remote get` subcommand.
#[derive(Args)]
pub struct GetArgs {
    /// Cache image name (required)
    name: String,
}

/// Executes the `get` subcommand.
///
/// Reads `uri.toml` from the local cache, downloads all listed packages
/// (or source lists) into a `debs/` or `sources/` directory, and decompresses
/// `.xz` files if in Update mode.
///
/// # Errors
/// Returns an error if reading `uri.toml` fails, creating directories fails,
/// or downloading files encounters unrecoverable issues.
pub fn run(args: GetArgs) -> Result<()> {
    let name = &args.name;

    // Locate cache directory for the given image
    let cache_dir = dirs::cache_dir()
        .context("Failed to locate cache directory")?
        .join("apt-remote")
        .join(name);

    // Load metadata from uri.toml
    let uri_file_path = cache_dir.join("uri.toml");
    let uri_file = UriFile::load(&uri_file_path).context("Failed to load uri.toml metadata")?;
    
    // Determine target directory based on operation mode
    let dir = match uri_file.mode {
        RemoteMode::Install | RemoteMode::Upgrade => "debs",
        RemoteMode::Update => "sources",
    };
    let download_dir = cache_dir.join(dir);
    fs::create_dir_all(&download_dir)?;

    // HTTP client for downloads (5-minute timeout)
    let client = Arc::new(
        Client::builder()
            .timeout(Duration::from_secs(300))
            .build()
            .context("Failed to build client")?,
    );

    // Shared progress tracker for multiple downloads
    let progress = Arc::new(MultiProgress::new());

    // Overall progress bar (counts completed packages)
    let progress_overall = progress.add(ProgressBar::new(uri_file.packages.len() as u64));
    progress_overall.set_style(
        ProgressStyle::default_bar()
            .template(
                "[{elapsed_precise}] {msg} [{wide_bar:.bold.cyan}] {pos}/{len} ({eta} remaining)",
            )
            .unwrap()
            .progress_chars("##-"),
    );
    progress_overall.enable_steady_tick(Duration::from_millis(100));
    progress_overall.set_message(format!("Downloading {name}..."));

    // Parallel download of each package
    uri_file
        .packages
        .par_iter()
        .try_for_each(|(fname, pkg)| -> Result<()> {
            let dest = download_dir.join(fname);

            if dest.exists() {
                return Ok(()); // Skip if file already exists
            }

            let client = Arc::clone(&client);
            let progress = Arc::clone(&progress);
            let progress_overall = progress_overall.clone();

            // Spinner for individual file download
            let spinner = progress.add(ProgressBar::new_spinner());
            spinner.set_style(
                ProgressStyle::with_template("\t{spinner:.bold.cyan} {msg}")
                    .unwrap()
                    .tick_chars("⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"),
            );
            spinner.set_message(format!("{} {}", "Downloading".cyan().bold(), fname.bold()));
            spinner.enable_steady_tick(std::time::Duration::from_millis(80));

            // Request file from URI
            let response = client.get(&pkg.uri).send();

            // Handle network errors
            if let Err(e) = response {
                spinner.finish_with_message(format!(
                    "{} {}:\n{}",
                    "✗".red().bold(),
                    format!("Failed to download {}", fname).red(),
                    e.to_string().dimmed()
                ));
                return Ok(()); // Skip instead of failing whole run
            }

            let response = response?.error_for_status();

            // Handle HTTP errors
            if let Err(e) = response {
                if uri_file.mode == RemoteMode::Install {
                    spinner.finish_with_message(format!(
                        "{} {}:\n{}",
                        "✗".red().bold(),
                        format!("Bad response for {}", name).red(),
                        e.to_string().dimmed()
                    ));
                }
                return Ok(());
            }

            // Save downloaded file to disk
            let extension = dest.extension().unwrap().to_str().unwrap();
            let mut file = File::create(&dest)?;
            file.write_all(&response?.bytes()?)?;

            // Auto-decompress .xz files if in Update mode
            if uri_file.mode == RemoteMode::Update && extension == "xz" {
                spinner.set_message(format!("{} {}", "Uncompressing".cyan().bold(), fname.bold()));
                 
                let original_path = Path::new(&dest);
                let output_path = original_path.with_extension(""); // removes .xz

                let input_file = File::open(&original_path)?;
                let mut decoder = XzDecoder::new_multi_decoder(BufReader::new(input_file));

                let output_file = File::create(&output_path)?;
                let mut writer = BufWriter::new(output_file);

                std::io::copy(&mut decoder, &mut writer)?;

                // Remove original compressed file
                std::fs::remove_file(&original_path)?;
            }

            spinner.finish_and_clear();
            progress_overall.inc(1);
            Ok(())
        })?;

    // Mark overall progress as complete
    progress_overall.finish_with_message(format!(
        "{} {}",
        "✓".green().bold(),
        format!("Downloaded {}", name).green()
    ));
    
    println!("\n");
    Ok(())
}
